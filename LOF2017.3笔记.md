#Solid Software Engineer笔记2017.3
> A complete answer will include the following:
>* Dcoument your assumptions
>* Explain your approach and how you intend to solve the problem
>* Provide code comments where applicable
>* Explain the big-O run time complexity of your solution. Justify your answer.
>* Identify any additional data structures you used and justify why you used them.
>* Only provde your best answer to each part of the question.

## Class 1 Array and Sorting Algorithms
讲代码，从总体到局部，比如先讲方法是干什么的，参数是干什么的，再讲方法内的具体实现细节，corner cases，数据结构，逻辑，返回类型等等。
### Merge Sort
1. Merge Sort用于LinkedList也可以，并且时间复杂度也是O(nlogn)，因为虽然找终点需要O(n)的复杂度，但是后面的merge为O(n)
2. 什么是面试中一个类型的题？
    * A1B2C3D4 -> ABCD1234，只是combine function的实现稍微不一样而已；
    * ABCD1234 -> A1B2C3D4，这个跟上一个有何区别？反向merge sort。
    * K-way merge and its application in **Mapreduce**,e.g. how to merge TB/PB level data? **Algorithm** + **System Design**
    * count-array problem
    <br/>
    Given an array A[N] with all positive integers from [1...N]. how to get an Array B[N] such that B[i] represents how many elements A[j](j > i) in array A[] that are smaller than A[i]. For example, given A[N]{4, 1, 3, 2},we should get B[N]={3, 0, 1, 0}.
    <br/>Requirement: Time = O(nlogn).
    
    <br/>
    **性质：** 在log(n)层中，combine function能够让每个element都会和其他所有元素的compare至少一次，总的时间复杂度依然是O(nlogn)。
    
### Quick Sort
1. What is the worst case scenario for quicksort? Can you provide an example?
2. 什么是面试中一个类型的题？
    * Array Shuffling 1:
    <br/>
    Given an array with integers,move all "0s" to the right-end of the array. (2个挡板，3个区域，相向而行)
    <br/>
    * Character removal from a string:
    <br/>
    (2个挡板，3个区域，同向而行)
    <br/>
    Remove one or more types of characters from a string.
    <br/>
    * Quick Partition Problems
    <br/>
    (2个挡板，3个区域，相向而行)
    <br/>
    * Rainbow sort (abcccabbcbbacaa -> aaaaa bbbbb ccccc)
    <br/>
    (3个挡板，4个区域，同向+相向而行)
    <br/>
    **Example**:<br/>
        aaaa bbbbbXxxxxxCcccc<br/>
             [i   j->  k   [j,k]为位置探索区域<br/>
    **Initialization**:<br/>
    i = 0; all letters to the left-hand side of i are all "a"s,<br/>
    j = 0; (j is actually the current index) all letters in [i, j) are all "b"s,<br/>
    k = n - 1; (all letters to the right-hand side of k are all "c"s).<br/>
    unknown area is [j...k]
## Class 2 Recursion
### Recursion
1. 表象上：function calls itself
2. Boil down a big problem to smaller ones(size n depends on size n-1, or n-2 or ... n/2)
3. Implementation上：<br />
    * Base case: smallest problem to solve;<br />
    * Recursive rule: how to make the problem smaller (if we can resolve the same problem but with a smaller size, then what is left to do for the current problem size n)

分析时间空间复杂度牢记递归树，例如，求斐波那契树的递归解法
```java
class Fibonacci {
    public int getFibonacci(int n) {
        if (n == 0) {
            return 0;
        }
        if (n == 1) {
            return 1;
        }
        return getFibonacci(n - 1) + getFibonacci(n - 2);
    }
}
```
<br />

例如n==4, <br />

![](/images/lof1.PNG)

<br />
**时间复杂度**为每一层的操作加起来，1 + 2 + 4 + 8 + ... + 2^(n-1) = O(2^n)，递归树本质是一个二叉树，for binary tree,the number of all leaf nodes is larger than the rest nodes in the binary tree. Thus, we only care about the nodes in the leaf level. 
<br />
**空间复杂度**则是只看递归栈压的层，也就是调用的层数，跟node的总数关系不大，比如斐波那契数的递归解法，为O(n), how many call stacks are there in the recursion tree == level of recursion tree.

<br />

**递归调用栈**call_stack:<br />
1. 一种存储机制， global accessible resource
2. Usage: store the local information for each recursion function


## Class 3 Stack & Linked List

## Class 4 Binary Tree & Binary Search Tree

## Class 5 Heap & Graph

## Class 6 HashTable

## Class 7 Object Oriented Design (1)

## Class 8 数据结构自测摸底

