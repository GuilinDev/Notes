#二叉树实战代码

##二叉树的数据结构
```java
class TreeNode {
    int val;
    // Left Child
    TreeNode left;
    // Right Child
    TreeNode right;
}
```
>二叉树的实战题大概分三类：
* Preorder/Inorder/Postorder Traverse相关的题，递归和迭代，略占20%；
* Levelorder Traverse相关的题（BFS），递归和迭代，略占10%；
* 剩下70%的题，都用递归或者分治法来做，Iterative的方法不强求。

### 1. 求二叉树的最大深度
```java
int maxDepth(TreeNode node) {
    if(node == null) {
        return 0;
    }
    int left = maxDepth(node.left);
    int right = maxDepth(node.right);
    
    return Math.max(left, right) + 1; //递归的层数+1
}
```
### 2. 求二叉树的最小深度 
### 3. 求二叉树中结点的个数
### 4. 求二叉树中叶子结点的个数
### 5. 求二叉树中第k层的结点的个数
### 6. 判断是否为平衡二叉树
### 7. 判断是否是完全二叉树
### 8. 判断两个二叉树是否相同
### 9. 判读两个二叉树是否互为镜像
### 10. 翻转二叉树（镜像二叉树）
### 11. 求两个二叉树的最低公共祖先
### 12. 二叉树的前序遍历
### 13. 二叉树的中序遍历
### 14. 二叉树的后序遍历
### 15. 前序+中序构建二叉树
### 16. 中序+后序构建二叉树
### 17. 二叉树的层序遍历
### 18. 在二叉树中插入结点
### 19. 输入一个二叉树和一个整数，打印出二叉树中节点值的和等于输入整数所有的路径
### 20. 二叉树的搜索区间
### 21. 二叉树中两个结点的最长距离
### 22. 不同的二叉树
### 23. 判断二叉树是否为BST
