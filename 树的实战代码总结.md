#树的实战代码

>树，主要是二叉树，实战题大概分三类：
>* Preorder/Inorder/Postorder Traverse相关的题，递归和迭代，略占20%；
>* Levelorder Traverse相关的题（BFS），递归和迭代，略占10%；
>* 剩下70%的题，都用递归或者分治法来做，Iterative的方法不强求。

## 二叉树的数据结构
```java
class TreeNode {
    int val;
    // Left Child
    TreeNode left;
    // Right Child
    TreeNode right;
}
```

### 1. 求二叉树的最大深度
也就是根节点到最远叶子节点的距离
```java
int maxDepth(TreeNode root) {
    if(root == null) {
        return 0;
    }
    int left = maxDepth(root.left);
    int right = maxDepth(root.right);
    
    return Math.max(left, right) + 1; //递归的层数+1
}
```
### 2. 求二叉树的最小深度 
也就是根节点到最近叶子节点的距离
```java
int getMinDepth(TreeNode node) {
    if (root == null) {
        return 0;
    }
    return getMin(root);
}
int getMin(TreeNode root) {
    if (root == null) {
        return Integer.MAX_VALUE;
    }
    if (root.left == null && root.right == null) {//没有左右儿子了就在该结点处返回1
        return 1;
    }
    return Math.min(getMin(root.left), getMin(root.right)) + 1;
}
```
### 3. 求二叉树中结点的个数
```java
int numOfTreeNodes(TreeNode root) {
    if (root == null) {
        return 0;
    }
    int left = numOfTreeNodes(root.left);
    int right = numOfTreeNodes(root.right);
    
    return left + right + 1;//算上root自己，+1
}
```
### 4. 求二叉树中叶子结点的个数
```java
int numOfChildNodes(Tree root) {
    if (root == null) {
        return 0;
    }
    if (root.left == null && root.right == null) {
        return 1;
    }
    
    return numOfChildNodes(root.left) + numOfChildNodes(root.right);//这里就不用+1了
}
```
### 5. 求二叉树中第k层的结点的个数
k从1开始计数
```java
int numOfLevelKNodes(TreeNode root, int k) {
    if (root == null || k < 1) {
        return 0;
    }
    if (k == 1) {
        return 1;
    }
    
    //k-1，每次递归往k层递进一步
    int left = numOfLevelKNodes(root.left, k - 1);
    int right = numOfLevelKNodes(root.right, k - 1);
    
    return left + right;
}
```
### 6. 判断是否为平衡二叉树
递归检查左右子树的最大深度的差是否超过1
```java
boolean isBalancedTree(TreeNode root) {
    if (root == null) {
        return true;
    }
    return maxDepth(root) != -1;
}

//返回最大深度
int maxDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    int left = maxDepth(root.left);
    int right = maxDepth(root.right);
    //分别递归检查左右子树之间是否平衡和各自是否平衡
    if (left == -1 || right == -1 || Math.abs(left - right) > 1) {
        return -1;
    }
    
    //optional: 是平衡树的情况下返回最大深度
    return Math.max(left, right) + 1;
}
```
### 7. 判断是否是完全二叉树

### 8. 判断两个二叉树是否相同
### 9. 判读两个二叉树是否互为镜像
### 10. 翻转二叉树（镜像二叉树）
### 11. 求两个二叉树的最低公共祖先
### 12. 二叉树的前序遍历
### 13. 二叉树的中序遍历
### 14. 二叉树的后序遍历
### 15. 前序+中序构建二叉树
### 16. 中序+后序构建二叉树
### 17. 二叉树的层序遍历
### 18. 在二叉树中插入结点
### 19. 输入一个二叉树和一个整数，打印出二叉树中节点值的和等于输入整数所有的路径
### 20. 二叉树的搜索区间
### 21. 二叉树中两个结点的最长距离
### 22. 不同的二叉树
### 23. 判断二叉树是否为BST
