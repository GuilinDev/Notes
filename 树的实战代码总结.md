#树的实战代码

>树，主要是二叉树，实战题大概分三类：
>* Preorder/Inorder/Postorder Traverse相关的题，递归和迭代，略占20%；
>* Levelorder Traverse相关的题（BFS），递归和迭代，略占10%；
>* 剩下70%的题，都用递归或者分治法来做，Iterative的方法不强求。

## 二叉树的数据结构
```java
class TreeNode {
    int val;
    // Left Child
    TreeNode left;
    // Right Child
    TreeNode right;
}
```

### 1. 求二叉树的最大深度
也就是根节点到最远叶子节点的距离
```java
int maxDepth(TreeNode root) {
    if(root == null) {
        return 0;
    }
    int left = maxDepth(root.left);
    int right = maxDepth(root.right);
    
    return Math.max(left, right) + 1; //递归的层数+1
}
```
### 2. 求二叉树的最小深度 
也就是根节点到最近叶子节点的距离
```java
int getMinDepth(TreeNode node) {
    if (root == null) {
        return 0;
    }
    return getMin(root);
}
int getMin(TreeNode root) {
    if (root == null) {
        return Integer.MAX_VALUE;
    }
    if (root.left == null && root.right == null) {//没有左右儿子了就在该结点处返回1
        return 1;
    }
    return Math.min(getMin(root.left), getMin(root.right)) + 1;
}
```
### 3. 求二叉树中结点的个数
```java
int numOfTreeNodes(TreeNode root) {
    if (root == null) {
        return 0;
    }
    int left = numOfTreeNodes(root.left);
    int right = numOfTreeNodes(root.right);
    
    return left + right + 1;//算上root自己，+1
}
```
### 4. 求二叉树中叶子结点的个数
```java
int numOfChildNodes(Tree root) {
    if (root == null) {
        return 0;
    }
    if (root.left == null && root.right == null) {
        return 1;
    }
    
    return numOfChildNodes(root.left) + numOfChildNodes(root.right);//这里就不用+1了
}
```
### 5. 求二叉树中第k层的结点的个数
k从1开始计数
```java
int numOfLevelKNodes(TreeNode root, int k) {
    if (root == null || k < 1) {
        return 0;
    }
    if (k == 1) {
        return 1;
    }
    
    //k-1，每次递归往k层递进一步
    int left = numOfLevelKNodes(root.left, k - 1);
    int right = numOfLevelKNodes(root.right, k - 1);
    
    return left + right;
}
```
### 6. 判断是否为平衡二叉树
递归检查左右子树的最大深度的差是否超过1
```java
boolean isBalancedBinaryTree(TreeNode root) {
    if (root == null) {
        return true;
    }
    return maxDepth(root) != -1;
}

//返回最大深度
int maxDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    int left = maxDepth(root.left);
    int right = maxDepth(root.right);
    //分别递归检查左右子树之间是否平衡和各自是否平衡
    if (left == -1 || right == -1 || Math.abs(left - right) > 1) {
        return -1;
    }
    
    //optional: 是平衡树的情况下返回最大深度
    return Math.max(left, right) + 1;
}
```
### 7. 判断是否是完全二叉树
```java
boolean isCompleteBinaryTree(TreeNode root) {
    if (root == null) {
        return false; //注意null结点是返回false
    }
    boolean result = true;
    Queue<TreeNode> queue = new LinkedList<TreeNode>();
    queue.add(root);
    boolean hasNoChild = false;// 判断左子树或右子树是否还有孩子
    
    while (!queue.isEmpty()) {
        TreeNode current = queue.remove();
        if (hasNoChild) {//其中左子树和右子树的其中之一没有孩子了
            if (current.left != null || current.right != null) {// 而左子树和右子树的其中之一则还有孩子
                result = false;//肯定不平衡
                break;
            }
        } else {
            if (current.left != null && current.right != null) {//左右孩子都还有，入队列继续检查
                queue.add(current.left);
                queue.add(current.right);
            } else if (current.left != null && current.right != null) {//存在左孩子，没有右孩子，可能是可能不是
                queue.add(current.left);
                hasNoChild = true;//只有左孩子是非满结点
            } else if (current.left == null && current.right != null) {//没有左孩子，存在右孩子，根据完全二叉树的定义，肯定不是
                result = false;
                break;
            } else { // 左右孩子都存在，并为非满的状态，需要看后续
                hasNoChild = true;
            }
        }
    }
    return result;
}
```
### 8. 判断两个二叉树是否相同
```java
boolean isSameTree(TreeNode node1, TreeNode node2) {
    //递归的终止条件1
    if (node1 == null && node2 == null) {
        return true;
    } else if (node1 == null || node2 == null) {
        return false;
    }
    //递归的终止条件2
    if (node1.val != node2.val) {
        return false;
    }
    
    boolean left = isSameTree(node1.left, node2.left);
    boolean right = isSameTree(node2.right, node2.right);
    
    return left && right;
}
```
### 9. 判读两个二叉树是否互为镜像
```java
boolean isSymmetryTree(TreeNode node1, TreeNode node2) {
    if (node1 == null && node2 == null) {
        return true;
    } else if (node1 == null || node2 == null) {
        return false;
    }
    if (node1.val != node2.val) {
        return false;
    }
    
    boolean left = isSymmertyTree(node1.left, node2.right);
    boolean right = isSymmetryTree(node1.right, node2.left);
    
    return left && right;
}
```

### 10. 翻转二叉树（镜像二叉树）
```java
TreeNode reverseTree(TreeNode root) {
    if (root == null) {
        return root;
    }
    //新建两个变量来保存左右子树
    TreeNode left = reverseTree(root.left);
    TreeNode right = reverseTree(root.right);
    //赋值
    root.left = right;
    root.right = left;
    
    return root;
}
```

### 11. 求两个二叉树的最低公共祖先

### 12. 二叉树的前序遍历
### 13. 二叉树的中序遍历
### 14. 二叉树的后序遍历
### 15. 前序+中序构建二叉树
### 16. 中序+后序构建二叉树
### 17. 二叉树的层序遍历
### 18. 在二叉树中插入结点
### 19. 输入一个二叉树和一个整数，打印出二叉树中节点值的和等于输入整数所有的路径
### 20. 二叉树的搜索区间
### 21. 二叉树中两个结点的最长距离
### 22. 不同的二叉树
### 23. 判断二叉树是否为BST
