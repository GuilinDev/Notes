## 思路总结
##### 62 Unique Paths
bottom up的办法，先初始化第一行和第一列为1，然后递推公式为dp[i][j] = dp[i-1][j] + dp[i][j-1]，计算所有的路径总数，返回dp[m-1][n-1]。

##### 200 Number of Islands
DFS，遍历每一个二维数组里面的元素，当遇到‘1’时，利用DFS查找相同岛的元素，将所有的‘1’改成0。

##### 904 Fruit into Brasket 
用hashmap或者两个变量替换

##### 3 Longest Substring without Repeating Characters
双指针创建sliding window，利用HashMap<Character, Integer>, 遍历字符串的字符，key是字符串里的字符，value是记录该字符上一次出现的位置，left = Math.max(left, map.get(s.charAt(i)) + 1)更新左指针代表sliding window的左边界，右指针一直往前知道最末。

##### 5 Longest Panlindromic Substring
方法1：遍历字符串中的每一个字符，将这个字符和它的下一位作为center，两边扩展，记录一个最大的子字符串的长度；
方法2：DP的办法，二维DP。dp[i][j]表示从j到i是否是回文，判断i和j是否在同一位/相邻/不相邻的情况；
方法3：Manacher‘s算法，现在不要求；

##### 929 Unique Email Address
以email的@分成左右两部分，分别考虑。

##### 15 3Sum
先排序，然后三个指针，其中第一个指针套在外面，另外指针左右遍历Array，找到合适的triplets存入结果。

##### 20 Valid Parentheses
Stack来存，如果遇到左括号（大中小）就存入stack中，如果是遇到右括号（大中小）跟栈顶的元素对比，记得最后查一下stack为空。

##### Copy List with Random Pointer
比较常用的办法是用一个hashmap做两次遍历，第一次遍历将hashmap的key设为当前的node，hashmap的value设为以当前node的val的值新创建的一个node（这时候该node还没有设置next和random）；第二次遍历的时候，通过hashmap的get方法将前一次遍历时创建的新node（hashmap的value）的next指针和random指针通过hashmap的key来赋值。时空复杂度都是O(n)。

还有不用额外空间的办法：待续。

##### 56 Merge Intervals
先排序，然后根据第一个区间初始化start和end，然后遍历list，比较list中interval.start和刚才end的值，如果end >= interval.start，说明两个区间有重叠，这时将end更新为end和interval.end之间的较大值；如果end < interval.start，说明没有重叠区间，这时候将interval.start和interval.end直接实例化一个list加入到结果中。最后还要注意一下最后一个区间没有被遍历到，需要加入。

##### 21 Merge Two Sorted Lists


##### 146 LRU cache
为了保证O(1)，利用hashmap（取值） + double linked（存），put和get方法主要考虑已经存在或者不存在的两种情况
```java
class LRUCache {
    
    class Node {
        int key;
        int value;
        Node next;
        Node pre;
        public Node (int key, int value) {
            this.key = key;
            this.value = value;
        }
    }
    
    private HashMap<Integer, Node> map;
    private int capacity;
    private Node head;
    private Node tail;

    public LRUCache(int capacity) {
        map = new HashMap<>();
        this.capacity = capacity;
        head = null;
        tail = null;
    }
    
    public int get(int key) {
        Node node = map.get(key);
        if (node == null) {
            return -1;
        }
        if (node != tail) {
            if (node == head) {
                head = head.next;
            } else {
                node.pre.next = node.next;
                node.next.pre = node.pre;
            }
            tail.next = node;
            node.pre = tail;
            node.next = null;
            tail = node;
        }
        return node.value;
    }
    
    public void put(int key, int value) {
        Node node = map.get(key);
        if (node != null) {
            node.value = value;
            if (node != tail) {
                if (node == head) {
                    head = head.next;
                } else {//交换值
                    node.pre.next = node.next;
                    node.next.pre = node.pre;
                }
                tail.next = node;
                node.pre = tail;
                node.next = null;
                tail = node;
                
            }
        } else {
            Node newNode = new Node(key, value);
            if (capacity == 0) {
                Node temp = head;
                head = head.next;
                map.remove(temp.key);
                capacity++;
            }
            if (head == null && tail == null) {
                head = newNode;
            } else {
                tail.next = newNode;
                newNode.pre = tail;
                newNode.next = null;
            }
            tail = newNode;
            map.put(key, newNode);
            capacity--;
        }
    }
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
```
