## 思路总结
##### 62 Unique Paths
bottom up的办法，先初始化第一行和第一列为1，然后递推公式为dp[i][j] = dp[i-1][j] + dp[i][j-1]，计算所有的路径总数，返回dp[m-1][n-1]。

##### 200 Number of Islands
DFS，遍历每一个二维数组里面的元素，当遇到‘1’时，利用DFS查找相同岛的元素，将所有的‘1’改成0。

##### 904 Fruit into Brasket 

##### 3 Longest Substring without Repeating Characters
双指针创建sliding window，利用HashMap<Character, Integer>, 遍历字符串的字符，key是字符串里的字符，value是记录该字符上一次出现的位置，left = Math.max(left, map.get(s.charAt(i)) + 1)更新左指针代表sliding window的左边界，右指针一直往前知道最末。

##### 5 Longest Panlindromic Substring
方法1：遍历字符串中的每一个字符，将这个字符和它的下一位作为center，两边扩展，记录一个最大的子字符串的长度；
方法2：DP的办法，二维DP。dp[i][j]表示从j到i是否是回文，判断i和j是否在同一位/相邻/不相邻的情况；
方法3：Manacher‘s算法，现在不要求；

##### 929 Unique Email Address
以email的@分成左右两部分，分别考虑。

##### 15 3Sum
先排序，然后三个指针，其中第一个指针套在外面，另外指针左右遍历Array，找到合适的triplets存入结果。

##### 20 Valid Parentheses
Stack来存，如果遇到左括号（大中小）就存入stack中，如果是遇到右括号（大中小）跟栈顶的元素对比，记得最后查一下stack为空。

