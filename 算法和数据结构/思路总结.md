## 思路总结
##### 62 Unique Paths
bottom up的办法，先初始化第一行和第一列为1，然后递推公式为dp[i][j] = dp[i-1][j] + dp[i][j-1]，计算所有的路径总数，返回dp[m-1][n-1]。

##### 200 Number of Islands
DFS，遍历每一个二维数组里面的元素，当遇到‘1’时，利用DFS查找相同岛的元素，将所有的‘1’改成0。

##### 904 Fruit into Brasket 
用hashmap或者两个变量替换

##### 3 Longest Substring without Repeating Characters
双指针创建sliding window，利用HashMap<Character, Integer>, 遍历字符串的字符，key是字符串里的字符，value是记录该字符上一次出现的位置，left = Math.max(left, map.get(s.charAt(i)) + 1)更新左指针代表sliding window的左边界，右指针一直往前知道最末。

##### 5 Longest Panlindromic Substring
方法1：遍历字符串中的每一个字符，将这个字符和它的下一位作为center，两边扩展，记录一个最大的子字符串的长度；
方法2：DP的办法，二维DP。dp[i][j]表示从j到i是否是回文，判断i和j是否在同一位/相邻/不相邻的情况；
方法3：Manacher‘s算法，现在不要求；

##### 929 Unique Email Address
以email的@分成左右两部分，分别考虑。

##### 15 3Sum
先排序，然后三个指针，其中第一个指针套在外面，另外指针左右遍历Array，找到合适的triplets存入结果。

##### 20 Valid Parentheses
Stack来存，如果遇到左括号（大中小）就存入stack中，如果是遇到右括号（大中小）跟栈顶的元素对比，记得最后查一下stack为空。

##### Copy List with Random Pointer
比较常用的办法是用一个hashmap做两次遍历，第一次遍历将hashmap的key设为当前的node，hashmap的value设为以当前node的val的值新创建的一个node（这时候该node还没有设置next和random）；第二次遍历的时候，通过hashmap的get方法将前一次遍历时创建的新node（hashmap的value）的next指针和random指针通过hashmap的key来赋值。时空复杂度都是O(n)。

还有不用额外空间的办法：待续。

##### 56 Merge Intervals
先排序，然后根据第一个区间初始化start和end，然后遍历list，比较list中interval.start和刚才end的值，如果end >= interval.start，说明两个区间有重叠，这时将end更新为end和interval.end之间的较大值；如果end < interval.start，说明没有重叠区间，这时候将interval.start和interval.end直接实例化一个list加入到结果中。最后还要注意一下最后一个区间没有被遍历到，需要加入。

##### 21 Merge Two Sorted Lists


##### 146 LRU cache
为了保证O(1)，利用hashmap（取值） + double linked（存），put和get方法主要考虑已经存在或者不存在的两种情况
```java
class LRUCache {
    
    class Node {
        int key;
        int value;
        Node next;
        Node pre;
        public Node (int key, int value) {
            this.key = key;
            this.value = value;
        }
    }
    
    private HashMap<Integer, Node> map;
    private int capacity;
    private Node head;
    private Node tail;

    public LRUCache(int capacity) {
        map = new HashMap<>();
        this.capacity = capacity;
        head = null;
        tail = null;
    }
    
    public int get(int key) {
        Node node = map.get(key);
        if (node == null) {
            return -1;
        }
        if (node != tail) {
            if (node == head) {
                head = head.next;
            } else {
                node.pre.next = node.next;
                node.next.pre = node.pre;
            }
            tail.next = node;
            node.pre = tail;
            node.next = null;
            tail = node;
        }
        return node.value;
    }
    
    public void put(int key, int value) {
        Node node = map.get(key);
        if (node != null) {
            node.value = value;
            if (node != tail) {
                if (node == head) {
                    head = head.next;
                } else {//交换值
                    node.pre.next = node.next;
                    node.next.pre = node.pre;
                }
                tail.next = node;
                node.pre = tail;
                node.next = null;
                tail = node;
                
            }
        } else {
            Node newNode = new Node(key, value);
            if (capacity == 0) {
                Node temp = head;
                head = head.next;
                map.remove(temp.key);
                capacity++;
            }
            if (head == null && tail == null) {
                head = newNode;
            } else {
                tail.next = newNode;
                newNode.pre = tail;
                newNode.next = null;
            }
            tail = newNode;
            map.put(key, newNode);
            capacity--;
        }
    }
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
```

##### 460 LFU Cache

##### 31 Next Permutaion
将数组从后先前看，找到的第一个降序的数字，记下它的坐标p；然后第二次再从后向前查找，找到第一个比p坐标位置的数大的数，二者swap；然后将swap后的p后面的所有的数reverse，得到的数组即为next permutation。

corner case：第一遍找p坐标如果没找到（也就是说整个数组是降序），那说明该数组是最大的permutation，那就它的下一个排列就是最小的，直接reverse就行了。

##### 1005 Maximize Sum Of Array After K Negations
先排序，然后判断从左到右判断是否为负数，负数就转为正数，如果所有负数都转换完了K值还不为0，那就判读是否有0，有的话可以直接终止查找，没有0的话就判断最后转换的那个负数（已转换为正数）和第一个正数看哪个小，将值小的那个值判断下剩余K值的奇偶看是正还是负，相应取正负，最后将数组里面的所有值相加返回最后结果。

##### 1006 Clumsy Factorial
先把乘法和除法做好，然后加法，作为一个整体；然后判断是否是第一次，如果是赋值给临时变量，不是第一次就将下一轮的乘法和除法作为一个整体，被上一轮的临时变量值（乘法除法加法一起）减掉，注意corner cases比如1，5，9，10这样的值。

##### 17 Letter Combinations of a Phone Number
BFS做法，创建一个对应每个键的string array，依然用queue，考虑树形结构，按层次来，第一层为空，第二层为在空的基础上加上一个字符，第三层在第二层的基础上再加上一个字符，直到某一层节点字符串的长度等于所要求的长度就返回该层所有节点。

DFS做法，创建一个对应每个键的string array，递归树中，当字符串长度等于要求的长度时作为出口，否则还未达到长度的时候，依次找到输入的字符串对应的按键的字符，用offset控制是哪一个按键，进入下一层递归，直到长度符合。

##### 289 Game of Life
这道题的难点是in place，利用状态机，使用两次遍历，第一次遍历将每个下一个generation为活细胞的转换成状态1或者状态3（死细胞总是0），这样不会影响后面细胞的计算，第二次遍历将每个细胞的状态对2进行取余，得到的结果就是下一个generation的细胞状态。单独写一个method来计算第一遍循环中每个细胞八个邻居的死活状态。

##### 242 Valid Anagram
排序后比较是否相同比较费时；用一个26大小的数组来统计字符出现的次数，counts[ch - 'a']，第一个循环++，第二个循环--，第三次循环counts看是否有不等于0的字符，小优化是省掉第三个循环，在第二个循环的时候直接判断是否有字符出现的次数小于0，有的话直接返回false。用HashMap来统计也可以，同样的做法，如果follow up是unicode需要用到codePoints()方法来计算是占几个位置。

##### 409 Longest Palindrome
使用一个256长度的数组来统计字符出现的次数，因为每两个字符可以组成一个回文，然后每个字符出现的次数（无论奇偶，地板除法）除以2再乘以2，就是偶数的最长回文，这时候再检查一下这个最长回文的长度是否等于原来的字符串，如果不等于（其实是小于，因为地板除法的缘故），说明有字符出现的次数被地板除法除掉了，可以拿一个字符回来放在回文串的正中。

##### 205 Isomorphic Strings
用两个256长度的数组（或者一个512长度的数组，比较前256位和后256位），每次对应的两个字符存同样的不为0的整数，再遇到的时候比较存的两个整数，不用就返回false，相同就一直比到字符串末尾。

##### 647 Palindromic Substrings
正常判断一个中心和两个中心的情况(i, i和i, i + 1)，注意下检查每个字符的循环中需要检查到最后一个字符，i+1虽然越界但checkPalindrome的方法中while循环会跳过越界的。